{"version":3,"sources":["src/sdk/Recognizer.ts"],"names":[],"mappings":"AAGA,OAAO,EAIH,eAAe,EACf,kBAAkB,EAElB,eAAe,EACf,gBAAgB,EAChB,qBAAqB,EACrB,mBAAmB,EACtB,MAAM,0BAA0B,CAAC;AAClC,OAAO,EAAE,OAAO,EAAiB,MAAM,mBAAmB,CAAC;AAE3D,OAAO,EACH,WAAW,EAEX,kBAAkB,EAElB,oBAAoB,EACpB,gBAAgB,EAChB,uBAAuB,EAC1B,MAAM,WAAW,CAAC;AAEnB;;;GAGG;AACH,8BAAsB,UAAU;IAC5B,OAAO,CAAC,YAAY,CAAU;IAC9B,SAAS,CAAC,WAAW,EAAE,WAAW,CAAC;IACnC,SAAS,CAAC,QAAQ,EAAE,qBAAqB,CAAC;IAC1C,SAAS,CAAC,cAAc,EAAE,kBAAkB,CAAC;IAC7C,OAAO,CAAC,qBAAqB,CAAqB;IAElD;;;;OAIG;IACH,SAAS,aAAa,WAAW,EAAE,WAAW,EAAE,UAAU,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,kBAAkB;IAQrH;;;;;OAKG;IACI,cAAc,EAAE,CAAC,MAAM,EAAE,UAAU,EAAE,KAAK,EAAE,gBAAgB,KAAK,IAAI,CAAC;IAE7E;;;;;OAKG;IACI,cAAc,EAAE,CAAC,MAAM,EAAE,UAAU,EAAE,KAAK,EAAE,gBAAgB,KAAK,IAAI,CAAC;IAE7E;;;;;OAKG;IACI,mBAAmB,EAAE,CAAC,MAAM,EAAE,UAAU,EAAE,KAAK,EAAE,oBAAoB,KAAK,IAAI,CAAC;IAEtF;;;;;OAKG;IACI,iBAAiB,EAAE,CAAC,MAAM,EAAE,UAAU,EAAE,KAAK,EAAE,oBAAoB,KAAK,IAAI,CAAC;IAEpF;;;;;OAKG;IACI,KAAK,IAAI,IAAI;IAMpB;;;;OAIG;IACH,IAAW,YAAY,IAAI,MAAM,CAEhC;IAED;;;;;;;;;OASG;IACH,SAAS,CAAC,OAAO,CAAC,SAAS,EAAE,OAAO,GAAG,IAAI;IAe3C;;;;;;OAMG;IACH,WAAkB,gBAAgB,IAAI,OAAO,CAE5C;IAED;;;;;;;;;OASG;WAEW,eAAe,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI;IAUrD,SAAS,CAAC,QAAQ,CAAC,sBAAsB,CAAC,YAAY,EAAE,mBAAmB,GAAG,gBAAgB;IAG9F,SAAS,CAAC,QAAQ,CAAC,uBAAuB,CACtC,cAAc,EAAE,eAAe,EAC/B,iBAAiB,EAAE,kBAAkB,EACrC,WAAW,EAAE,WAAW,EACxB,gBAAgB,EAAE,gBAAgB,GAAG,qBAAqB;IAG9D,SAAS,CAAC,yBAAyB,IAAI,IAAI;IAoC3C,SAAS,CAAC,sBAAsB,CAAC,eAAe,EAAE,eAAe,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,uBAAuB,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,MAAM,KAAK,IAAI,GAAG,IAAI;IA8DvI,mCAAmC,CAAC,eAAe,EAAE,eAAe,EAAE,EAAE,CAAC,EAAE,MAAM,IAAI,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,MAAM,KAAK,IAAI,GAAG,IAAI;IA8C9H,SAAS,CAAC,kCAAkC,CAAC,EAAE,CAAC,EAAE,MAAM,IAAI,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,MAAM,KAAK,IAAI,GAAG,IAAI;IAmC9F,SAAS,CAAC,kBAAkB,IAAI,OAAO,CAAC,OAAO,CAAC;CAMnD","file":"Recognizer.d.ts","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    CognitiveSubscriptionKeyAuthentication,\r\n    CognitiveTokenAuthentication,\r\n    Context,\r\n    IAuthentication,\r\n    IConnectionFactory,\r\n    OS,\r\n    RecognitionMode,\r\n    RecognizerConfig,\r\n    ServiceRecognizerBase,\r\n    SpeechServiceConfig,\r\n} from \"../common.speech/Exports\";\r\nimport { Promise, PromiseHelper } from \"../common/Exports\";\r\nimport { Contracts } from \"./Contracts\";\r\nimport {\r\n    AudioConfig,\r\n    Connection,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    RecognitionEventArgs,\r\n    SessionEventArgs,\r\n    SpeechRecognitionResult,\r\n} from \"./Exports\";\r\n\r\n/**\r\n * Defines the base class Recognizer which mainly contains common event handlers.\r\n * @class Recognizer\r\n */\r\nexport abstract class Recognizer {\r\n    private privDisposed: boolean;\r\n    protected audioConfig: AudioConfig;\r\n    protected privReco: ServiceRecognizerBase;\r\n    protected privProperties: PropertyCollection;\r\n    private privConnectionFactory: IConnectionFactory;\r\n\r\n    /**\r\n     * Creates and initializes an instance of a Recognizer\r\n     * @constructor\r\n     * @param {AudioConfig} audioInput - An optional audio input stream associated with the recognizer\r\n     */\r\n    protected constructor(audioConfig: AudioConfig, properties: PropertyCollection, connectionFactory: IConnectionFactory) {\r\n        this.audioConfig = (audioConfig !== undefined) ? audioConfig : AudioConfig.fromDefaultMicrophoneInput();\r\n        this.privDisposed = false;\r\n        this.privProperties = properties.clone();\r\n        this.privConnectionFactory = connectionFactory;\r\n        this.implCommonRecognizerSetup();\r\n    }\r\n\r\n    /**\r\n     * Defines event handler for session started events.\r\n     * @member Recognizer.prototype.sessionStarted\r\n     * @function\r\n     * @public\r\n     */\r\n    public sessionStarted: (sender: Recognizer, event: SessionEventArgs) => void;\r\n\r\n    /**\r\n     * Defines event handler for session stopped events.\r\n     * @member Recognizer.prototype.sessionStopped\r\n     * @function\r\n     * @public\r\n     */\r\n    public sessionStopped: (sender: Recognizer, event: SessionEventArgs) => void;\r\n\r\n    /**\r\n     * Defines event handler for speech started events.\r\n     * @member Recognizer.prototype.speechStartDetected\r\n     * @function\r\n     * @public\r\n     */\r\n    public speechStartDetected: (sender: Recognizer, event: RecognitionEventArgs) => void;\r\n\r\n    /**\r\n     * Defines event handler for speech stopped events.\r\n     * @member Recognizer.prototype.speechEndDetected\r\n     * @function\r\n     * @public\r\n     */\r\n    public speechEndDetected: (sender: Recognizer, event: RecognitionEventArgs) => void;\r\n\r\n    /**\r\n     * Dispose of associated resources.\r\n     * @member Recognizer.prototype.close\r\n     * @function\r\n     * @public\r\n     */\r\n    public close(): void {\r\n        Contracts.throwIfDisposed(this.privDisposed);\r\n\r\n        this.dispose(true);\r\n    }\r\n\r\n    /**\r\n     * @Internal\r\n     * Internal data member to support fromRecognizer* pattern methods on other classes.\r\n     * Do not use externally, object returned will change without warning or notice.\r\n     */\r\n    public get internalData(): object {\r\n        return this.privReco;\r\n    }\r\n\r\n    /**\r\n     * This method performs cleanup of resources.\r\n     * The Boolean parameter disposing indicates whether the method is called\r\n     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).\r\n     * Derived classes should override this method to dispose resource if needed.\r\n     * @member Recognizer.prototype.dispose\r\n     * @function\r\n     * @public\r\n     * @param {boolean} disposing - Flag to request disposal.\r\n     */\r\n    protected dispose(disposing: boolean): void {\r\n        if (this.privDisposed) {\r\n            return;\r\n        }\r\n\r\n        if (disposing) {\r\n            if (this.privReco) {\r\n                this.privReco.audioSource.turnOff();\r\n                this.privReco.dispose();\r\n            }\r\n        }\r\n\r\n        this.privDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * This method returns the current state of the telemetry setting.\r\n     * @member Recognizer.prototype.telemetryEnabled\r\n     * @function\r\n     * @public\r\n     * @returns true if the telemetry is enabled, false otherwise.\r\n     */\r\n    public static get telemetryEnabled(): boolean {\r\n        return ServiceRecognizerBase.telemetryDataEnabled;\r\n    }\r\n\r\n    /**\r\n     * This method globally enables or disables telemetry.\r\n     * @member Recognizer.prototype.enableTelemetry\r\n     * @function\r\n     * @public\r\n     * @param enabled - Global setting for telemetry collection.\r\n     * If set to true, telemetry information like microphone errors,\r\n     * recognition errors are collected and sent to Microsoft.\r\n     * If set to false, no telemetry is sent to Microsoft.\r\n     */\r\n    /* tslint:disable:member-ordering */\r\n    public static enableTelemetry(enabled: boolean): void {\r\n        ServiceRecognizerBase.telemetryDataEnabled = enabled;\r\n    }\r\n\r\n    //\r\n    // ################################################################################################################\r\n    // IMPLEMENTATION.\r\n    // Move to independent class\r\n    // ################################################################################################################\r\n    //\r\n    protected abstract createRecognizerConfig(speechConfig: SpeechServiceConfig): RecognizerConfig;\r\n\r\n    // Creates the correct service recognizer for the type\r\n    protected abstract createServiceRecognizer(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioConfig: AudioConfig,\r\n        recognizerConfig: RecognizerConfig): ServiceRecognizerBase;\r\n\r\n    // Does the generic recognizer setup that is common across all recognizer types.\r\n    protected implCommonRecognizerSetup(): void {\r\n\r\n        let osPlatform = (typeof window !== \"undefined\") ? \"Browser\" : \"Node\";\r\n        let osName = \"unknown\";\r\n        let osVersion = \"unknown\";\r\n\r\n        if (typeof navigator !== \"undefined\") {\r\n            osPlatform = osPlatform + \"/\" + navigator.platform;\r\n            osName = navigator.userAgent;\r\n            osVersion = navigator.appVersion;\r\n        }\r\n\r\n        const recognizerConfig = this.createRecognizerConfig(\r\n            new SpeechServiceConfig(\r\n                new Context(new OS(osPlatform, osName, osVersion))));\r\n\r\n        const subscriptionKey = this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Key, undefined);\r\n        const authentication = (subscriptionKey && subscriptionKey !== \"\") ?\r\n            new CognitiveSubscriptionKeyAuthentication(subscriptionKey) :\r\n            new CognitiveTokenAuthentication(\r\n                (authFetchEventId: string): Promise<string> => {\r\n                    const authorizationToken = this.privProperties.getProperty(PropertyId.SpeechServiceAuthorization_Token, undefined);\r\n                    return PromiseHelper.fromResult(authorizationToken);\r\n                },\r\n                (authFetchEventId: string): Promise<string> => {\r\n                    const authorizationToken = this.privProperties.getProperty(PropertyId.SpeechServiceAuthorization_Token, undefined);\r\n                    return PromiseHelper.fromResult(authorizationToken);\r\n                });\r\n\r\n        this.privReco = this.createServiceRecognizer(\r\n            authentication,\r\n            this.privConnectionFactory,\r\n            this.audioConfig,\r\n            recognizerConfig);\r\n    }\r\n\r\n    protected recognizeOnceAsyncImpl(recognitionMode: RecognitionMode, cb?: (e: SpeechRecognitionResult) => void, err?: (e: string) => void): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privDisposed);\r\n\r\n            this.implRecognizerStop().on((_: boolean): void => {\r\n                try {\r\n                    this.privReco.recognize(recognitionMode, (e: SpeechRecognitionResult) => {\r\n                        this.implRecognizerStop().on((_: boolean): void => {\r\n                            if (!!cb) {\r\n                                cb(e);\r\n                            }\r\n                        }, (error: string): void => {\r\n                            if (!!err) {\r\n                                err(error);\r\n                            }\r\n                        });\r\n\r\n                    }, (e: string) => {\r\n                        this.implRecognizerStop(); // We're already in an error path so best effort here.\r\n                        if (!!err) {\r\n                            err(e);\r\n                        }\r\n                    /* tslint:disable:no-empty */\r\n                    }).on((_: boolean): void => { },\r\n                        (error: string) => {\r\n                            if (!!err) {\r\n                                err(error);\r\n                            }\r\n                        });\r\n                } catch (error) {\r\n                    if (!!err) {\r\n                        if (error instanceof Error) {\r\n                            const typedError: Error = error as Error;\r\n                            err(typedError.name + \": \" + typedError.message);\r\n                        } else {\r\n                            err(error);\r\n                        }\r\n                    }\r\n\r\n                    // Destroy the recognizer.\r\n                    this.dispose(true);\r\n                }\r\n            }, (error: string): void => {\r\n                if (!!err) {\r\n                    err(error);\r\n                }\r\n            });\r\n        } catch (error) {\r\n            if (!!err) {\r\n                if (error instanceof Error) {\r\n                    const typedError: Error = error as Error;\r\n                    err(typedError.name + \": \" + typedError.message);\r\n                } else {\r\n                    err(error);\r\n                }\r\n            }\r\n\r\n            // Destroy the recognizer.\r\n            this.dispose(true);\r\n        }\r\n    }\r\n\r\n    public startContinuousRecognitionAsyncImpl(recognitionMode: RecognitionMode, cb?: () => void, err?: (e: string) => void): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privDisposed);\r\n\r\n            this.implRecognizerStop().on((_: boolean): void => {\r\n                this.privReco.recognize(recognitionMode, undefined, undefined).on((_: boolean): void => {\r\n                    // report result to promise.\r\n                    if (!!cb) {\r\n                        try {\r\n                            cb();\r\n                        } catch (e) {\r\n                            if (!!err) {\r\n                                err(e);\r\n                            }\r\n                        }\r\n                        cb = undefined;\r\n                    }\r\n                }, (error: string): void => {\r\n                    if (!!err) {\r\n                        err(error);\r\n                    }\r\n                    // Destroy the recognizer.\r\n                    this.dispose(true);\r\n                });\r\n            }, (error: string): void => {\r\n                if (!!err) {\r\n                    err(error);\r\n                }\r\n                // Destroy the recognizer.\r\n                this.dispose(true);\r\n            });\r\n        } catch (error) {\r\n            if (!!err) {\r\n                if (error instanceof Error) {\r\n                    const typedError: Error = error as Error;\r\n                    err(typedError.name + \": \" + typedError.message);\r\n                } else {\r\n                    err(error);\r\n                }\r\n            }\r\n\r\n            // Destroy the recognizer.\r\n            this.dispose(true);\r\n        }\r\n    }\r\n\r\n    protected stopContinuousRecognitionAsyncImpl(cb?: () => void, err?: (e: string) => void): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privDisposed);\r\n\r\n            this.implRecognizerStop().on((_: boolean) => {\r\n                if (!!cb) {\r\n                    try {\r\n                        cb();\r\n                    } catch (e) {\r\n                        if (!!err) {\r\n                            err(e);\r\n                        }\r\n                    }\r\n                }\r\n            }, (error: string) => {\r\n                if (!!err) {\r\n                    err(error);\r\n                }\r\n            });\r\n\r\n        } catch (error) {\r\n            if (!!err) {\r\n                if (error instanceof Error) {\r\n                    const typedError: Error = error as Error;\r\n                    err(typedError.name + \": \" + typedError.message);\r\n                } else {\r\n                    err(error);\r\n                }\r\n            }\r\n\r\n            // Destroy the recognizer.\r\n            this.dispose(true);\r\n        }\r\n    }\r\n\r\n    protected implRecognizerStop(): Promise<boolean> {\r\n        if (this.privReco) {\r\n            return this.privReco.stopRecognizing();\r\n        }\r\n        return PromiseHelper.fromResult(true);\r\n    }\r\n}\r\n"]}