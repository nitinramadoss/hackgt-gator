// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
import { CognitiveSubscriptionKeyAuthentication, CognitiveTokenAuthentication, Context, OS, ServiceRecognizerBase, SpeechServiceConfig, } from "../common.speech/Exports";
import { PromiseHelper } from "../common/Exports";
import { Contracts } from "./Contracts";
import { AudioConfig, PropertyId, } from "./Exports";
/**
 * Defines the base class Recognizer which mainly contains common event handlers.
 * @class Recognizer
 */
export class Recognizer {
    /**
     * Creates and initializes an instance of a Recognizer
     * @constructor
     * @param {AudioConfig} audioInput - An optional audio input stream associated with the recognizer
     */
    constructor(audioConfig, properties, connectionFactory) {
        this.audioConfig = (audioConfig !== undefined) ? audioConfig : AudioConfig.fromDefaultMicrophoneInput();
        this.privDisposed = false;
        this.privProperties = properties.clone();
        this.privConnectionFactory = connectionFactory;
        this.implCommonRecognizerSetup();
    }
    /**
     * Dispose of associated resources.
     * @member Recognizer.prototype.close
     * @function
     * @public
     */
    close() {
        Contracts.throwIfDisposed(this.privDisposed);
        this.dispose(true);
    }
    /**
     * @Internal
     * Internal data member to support fromRecognizer* pattern methods on other classes.
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
        return this.privReco;
    }
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member Recognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */
    dispose(disposing) {
        if (this.privDisposed) {
            return;
        }
        if (disposing) {
            if (this.privReco) {
                this.privReco.audioSource.turnOff();
                this.privReco.dispose();
            }
        }
        this.privDisposed = true;
    }
    /**
     * This method returns the current state of the telemetry setting.
     * @member Recognizer.prototype.telemetryEnabled
     * @function
     * @public
     * @returns true if the telemetry is enabled, false otherwise.
     */
    static get telemetryEnabled() {
        return ServiceRecognizerBase.telemetryDataEnabled;
    }
    /**
     * This method globally enables or disables telemetry.
     * @member Recognizer.prototype.enableTelemetry
     * @function
     * @public
     * @param enabled - Global setting for telemetry collection.
     * If set to true, telemetry information like microphone errors,
     * recognition errors are collected and sent to Microsoft.
     * If set to false, no telemetry is sent to Microsoft.
     */
    /* tslint:disable:member-ordering */
    static enableTelemetry(enabled) {
        ServiceRecognizerBase.telemetryDataEnabled = enabled;
    }
    // Does the generic recognizer setup that is common across all recognizer types.
    implCommonRecognizerSetup() {
        let osPlatform = (typeof window !== "undefined") ? "Browser" : "Node";
        let osName = "unknown";
        let osVersion = "unknown";
        if (typeof navigator !== "undefined") {
            osPlatform = osPlatform + "/" + navigator.platform;
            osName = navigator.userAgent;
            osVersion = navigator.appVersion;
        }
        const recognizerConfig = this.createRecognizerConfig(new SpeechServiceConfig(new Context(new OS(osPlatform, osName, osVersion))));
        const subscriptionKey = this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Key, undefined);
        const authentication = (subscriptionKey && subscriptionKey !== "") ?
            new CognitiveSubscriptionKeyAuthentication(subscriptionKey) :
            new CognitiveTokenAuthentication((authFetchEventId) => {
                const authorizationToken = this.privProperties.getProperty(PropertyId.SpeechServiceAuthorization_Token, undefined);
                return PromiseHelper.fromResult(authorizationToken);
            }, (authFetchEventId) => {
                const authorizationToken = this.privProperties.getProperty(PropertyId.SpeechServiceAuthorization_Token, undefined);
                return PromiseHelper.fromResult(authorizationToken);
            });
        this.privReco = this.createServiceRecognizer(authentication, this.privConnectionFactory, this.audioConfig, recognizerConfig);
    }
    recognizeOnceAsyncImpl(recognitionMode, cb, err) {
        try {
            Contracts.throwIfDisposed(this.privDisposed);
            this.implRecognizerStop().on((_) => {
                try {
                    this.privReco.recognize(recognitionMode, (e) => {
                        this.implRecognizerStop().on((_) => {
                            if (!!cb) {
                                cb(e);
                            }
                        }, (error) => {
                            if (!!err) {
                                err(error);
                            }
                        });
                    }, (e) => {
                        this.implRecognizerStop(); // We're already in an error path so best effort here.
                        if (!!err) {
                            err(e);
                        }
                        /* tslint:disable:no-empty */
                    }).on((_) => { }, (error) => {
                        if (!!err) {
                            err(error);
                        }
                    });
                }
                catch (error) {
                    if (!!err) {
                        if (error instanceof Error) {
                            const typedError = error;
                            err(typedError.name + ": " + typedError.message);
                        }
                        else {
                            err(error);
                        }
                    }
                    // Destroy the recognizer.
                    this.dispose(true);
                }
            }, (error) => {
                if (!!err) {
                    err(error);
                }
            });
        }
        catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    const typedError = error;
                    err(typedError.name + ": " + typedError.message);
                }
                else {
                    err(error);
                }
            }
            // Destroy the recognizer.
            this.dispose(true);
        }
    }
    startContinuousRecognitionAsyncImpl(recognitionMode, cb, err) {
        try {
            Contracts.throwIfDisposed(this.privDisposed);
            this.implRecognizerStop().on((_) => {
                this.privReco.recognize(recognitionMode, undefined, undefined).on((_) => {
                    // report result to promise.
                    if (!!cb) {
                        try {
                            cb();
                        }
                        catch (e) {
                            if (!!err) {
                                err(e);
                            }
                        }
                        cb = undefined;
                    }
                }, (error) => {
                    if (!!err) {
                        err(error);
                    }
                    // Destroy the recognizer.
                    this.dispose(true);
                });
            }, (error) => {
                if (!!err) {
                    err(error);
                }
                // Destroy the recognizer.
                this.dispose(true);
            });
        }
        catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    const typedError = error;
                    err(typedError.name + ": " + typedError.message);
                }
                else {
                    err(error);
                }
            }
            // Destroy the recognizer.
            this.dispose(true);
        }
    }
    stopContinuousRecognitionAsyncImpl(cb, err) {
        try {
            Contracts.throwIfDisposed(this.privDisposed);
            this.implRecognizerStop().on((_) => {
                if (!!cb) {
                    try {
                        cb();
                    }
                    catch (e) {
                        if (!!err) {
                            err(e);
                        }
                    }
                }
            }, (error) => {
                if (!!err) {
                    err(error);
                }
            });
        }
        catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    const typedError = error;
                    err(typedError.name + ": " + typedError.message);
                }
                else {
                    err(error);
                }
            }
            // Destroy the recognizer.
            this.dispose(true);
        }
    }
    implRecognizerStop() {
        if (this.privReco) {
            return this.privReco.stopRecognizing();
        }
        return PromiseHelper.fromResult(true);
    }
}

//# sourceMappingURL=Recognizer.js.map
